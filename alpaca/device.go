package alpaca

import (
	"net/http"
)

type DeviceType string

const (
	DeviceTypeCamera      DeviceType = "Camera"
	DeviceTypeCover       DeviceType = "CoverCalibrator"
	DeviceTypeDome        DeviceType = "Dome"
	DeviceTypeFilterWheel DeviceType = "FilterWheel"
	DeviceTypeFocuser     DeviceType = "Focuser"
	DeviceTypeRotator     DeviceType = "Rotator"
	DeviceTypeSafety      DeviceType = "SafetyMonitor"
	DeviceTypeSwitch      DeviceType = "Switch"
	DeviceTypeTelescope   DeviceType = "Telescope"
)

func (dt DeviceType) String() string {
	return string(dt)
}

type DeviceInfo struct {
	Name        string     `json:"DeviceName"`
	Description string     `json:"-"`
	Type        DeviceType `json:"DeviceType"`
	UniqueID    string     `json:"UniqueID"`

	// TODO: Number should be generated by the server
	Number int `json:"DeviceNumber"`
}

type DriverInfo struct {
	Name             string
	Version          string
	InterfaceVersion int
}

type StateProperty struct {
	Name  string
	Value any
}

type Device interface {
	DeviceInfo() DeviceInfo
	DriverInfo() DriverInfo
	GetState() []StateProperty

	Connected() bool
	Connecting() bool
	Connect() error
	Disconnect() error

	HandleSetup(http.ResponseWriter, *http.Request)
}

type DeviceHandler struct {
	dev Device
}

func (h *DeviceHandler) RegisterRoutes(mux *http.ServeMux) {
	// mux.HandleFunc("GET /setup", h.handleSetup)
	mux.HandleFunc("GET /name", h.handleName)
	mux.HandleFunc("GET /description", h.handleDescription)
	mux.HandleFunc("GET /driverinfo", h.handleDriverInfo)
	mux.HandleFunc("GET /driverversion", h.handleDriverVersion)
	mux.HandleFunc("GET /interfaceversion", h.handleInterfaceVersion)
	mux.HandleFunc("GET /devicestate", h.handleState)
	mux.HandleFunc("GET /supportedactions", h.handleSupportedActions)

	mux.HandleFunc("/connected", h.handleConnected)
	mux.HandleFunc("GET /connecting", h.handleConnecting)
	mux.HandleFunc("PUT /connect", h.handleConnect)
	mux.HandleFunc("PUT /disconnect", h.handleDisconnect)

	mux.HandleFunc("/setup", h.dev.HandleSetup)
}

func (h *DeviceHandler) handleName(w http.ResponseWriter, r *http.Request) {
	handleResponse(w, r, h.dev.DeviceInfo().Name)
}

func (h *DeviceHandler) handleDescription(w http.ResponseWriter, r *http.Request) {
	handleResponse(w, r, h.dev.DeviceInfo().Description)
}

func (h *DeviceHandler) handleDriverInfo(w http.ResponseWriter, r *http.Request) {
	handleResponse(w, r, h.dev.DriverInfo())
}

func (h *DeviceHandler) handleDriverVersion(w http.ResponseWriter, r *http.Request) {
	handleResponse(w, r, h.dev.DriverInfo().Version)
}

func (h *DeviceHandler) handleInterfaceVersion(w http.ResponseWriter, r *http.Request) {
	handleResponse(w, r, h.dev.DriverInfo().InterfaceVersion)
}

func (h *DeviceHandler) handleState(w http.ResponseWriter, r *http.Request) {
	handleResponse(w, r, h.dev.GetState())
}

func (h *DeviceHandler) handleSupportedActions(w http.ResponseWriter, r *http.Request) {
	handleResponse(w, r, []string{})
}

func (h *DeviceHandler) handleConnected(w http.ResponseWriter, r *http.Request) {
	switch r.Method {
	case "PUT":
		connected, err := parseBoolRequest(r, "Connected")
		if err != nil {
			http.Error(w, "Invalid request", http.StatusBadRequest)
			return
		}

		if connected {
			if err := h.dev.Connect(); err != nil {
				handleError(w, r, 500, err.Error())
				return
			}
		} else {
			if err := h.dev.Disconnect(); err != nil {
				handleError(w, r, 500, err.Error())
				return
			}
		}
		handleResponse(w, r, connected)
	case "GET":
		handleResponse(w, r, h.dev.Connected())
	default:
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
	}
}

func (h *DeviceHandler) handleConnecting(w http.ResponseWriter, r *http.Request) {
	handleResponse(w, r, h.dev.Connecting())
}

func (h *DeviceHandler) handleConnect(w http.ResponseWriter, r *http.Request) {
	if err := h.dev.Connect(); err != nil {
		handleError(w, r, 500, err.Error())
		return
	}
	handleResponse(w, r, true)
}

func (h *DeviceHandler) handleDisconnect(w http.ResponseWriter, r *http.Request) {
	if err := h.dev.Disconnect(); err != nil {
		handleError(w, r, 500, err.Error())
		return
	}
	handleResponse(w, r, true)
}
